easySNES usage
v1.0 Jan 26, 2020

for ca65 assembler, to develop SNES games.
based on neslib.s by Shiru


stack starts at 1fff (recommend you don't change it)
direct page is at 0000 (recommend you don't move it)

all these functions, jsl to them (or use their macro)

the nmi code automatically sets scroll, copies the sprites
to the OAM, and (if there was a palette change) copies
the palette to the CGRAM.

also, there is an optional automated dma system for
vram updates.


reset_vram_system:
if using the automated vram system, do this at the start
of each frame to reset the variables.
  jsl reset_vram_system


bg_mode:
to set the bg mode. A = 0-7 =  mode
(A in 8 bit, any time)
  A8
  lda #1
  jsl bg_mode
  
or...
  SET_BG_MODE  1


bg3_priority:
to set the background 3 priority bit in $2105.
if A=0, bg3 will always be behind bg 1 and 2.
if A=8, bg3 tiles with priority bit clear will be behind
bg 1 and 2, bg3 tiles with priority bit set will be
in front of bg 1 and 2.
(A in 8 bit, any time)
  A8
  lda #BG3_TOP
  jsl bg3_priority

or...  
  SET_BG3_PRI  BG3_TOP

bg_tilesize:
to set backgrounds to either 8x8 or 16x16 tiles.
see examples in defines.asm, such as BG_ALL_8x8 or 
BG_ALL_16x16. 
(A in 8 bit, any time)
  A8
  lda #BG_ALL_8x8
  jsl bg_tilesize
  
or...  
  SET_BG_TILESIZE  BG_ALL_8x8
  
  
bg1_tile_addr:
to set the vram address of the tiles for bg1. A=x0-x7
In steps of $1000.
(A in 8 bit, forced blank)
  A8
  lda #6 ;for $6000
  jsl bg1_tile_addr
  
or...(use the full address)
  SET_BG1_TILE_ADDR  $6000
  
 
bg2_tile_addr:
to set the vram address of the tiles for bg2. A=0x-7x
In steps of $1000.
(A in 8 bit, forced blank)
  A8
  lda #$60 ;for $6000
  jsl bg2_tile_addr 
  
or...(use the full address)
  SET_BG2_TILE_ADDR  $6000
  
  
bg3_tile_addr:
to set the vram address of the tiles for bg3. A=x0-x7
In steps of $1000.
(A in 8 bit, forced blank)
  A8
  lda #6 ;for $6000
  jsl bg3_tile_addr
  
or...(use the full address)
  SET_BG3_TILE_ADDR  $6000
  
 
bg4_tile_addr:
to set the vram address of the tiles for bg4. A=0x-7x
In steps of $1000.
(A in 8 bit, forced blank)
  A8
  lda #$60 ;for $6000
  jsl bg4_tile_addr 
  
or...(use the full address)
  SET_BG4_TILE_ADDR  $6000  


bg1_map_addr:
to set the vram address of the tilemap for bg1.
In steps of $400, A = high byte.
Also, it sets a variable to the address called bg1_map_base
(A in 8 bit, forced blank)
  A8
  lda #$70 ;for $7000
  jsl bg1_map_addr
  
or...(use the full address)
  SET_BG1_MAP_ADDR  $6000

  
bg2_map_addr:
bg3_map_addr:
bg4_map_addr:
work the same as bg 1.
(variabls called bg2_map_base, bg3_map_base, bg4_map_base)
  
or...(use the full address)
  SET_BG2_MAP_ADDR  $6800
  SET_BG3_MAP_ADDR  $7000
  SET_BG4_MAP_ADDR  $7800
  
  
bg1_map_size:
to set the size of the tile map. 32x32,32x64,64x32, or 64x64
see examples in defines.asm, such as MAP_32_32.
(A in 8 bit, forced blank)
  A8
  lda #MAP_32_32
  jsl bg1_map_size
  
or...  
  SET_BG1_MAP_SIZE  MAP_32_32
  
  
bg2_map_size:
bg3_map_size:
bg4_map_size: 
work the same as bg 1.

or...  
  SET_BG2_MAP_SIZE  MAP_32_32
  SET_BG3_MAP_SIZE  MAP_32_32
  SET_BG4_MAP_SIZE  MAP_32_32


map_offset:
to get a vram address of a specific tile. This version works
for 32x32,32x64, and 64x32 sized maps.
(A in 16 bit, XY in 8 bit)
returns A = address offset, which you need to add to the
base address, such as bg1_map_base.
X = 0-31 or 0-63, Y = 0-31 or 0-63 = the x and y tile positions.
if you have pixel coordinates 0-255, divide by 8 (for 8x8 tiles)
Note: y max 27 if non-scrolling and screen size 224 pixel tall
(do any time)
	A16
	XY8
	ldx #3
	ldy #10
	jsl map_offset
	(returns A16 = the offset for the 3rd column, 10th row, tile)
	clc
	adc bg1_map_base ;if in bg 1
	(now have the exact address of that tile)
  
(no macro)


map_offset6464:
same as map_offset, except for 64x64 sized tilemaps.
X = 0-63, Y = 0-63.
  
(no macro)


oam_clear:
clears the sprite buffer. Do at the start of each frame.
  jsl oam_clear
  
(no macro)
  

oam_size:
sets the sizes of sprites.
see examples in defines.asm, such as OAM_8_16 for
8x8 small sprites and 16x16 large sprites.
(A in 8 bit, do any time)
  A8
  lda #OAM_8_16
  jsl oam_size
  
or...  
  SET_OAM_SIZE  OAM_8_16
  
  
oam_tile_addr:
sets the vram address for the sprite tiles.
in steps of $2000. A = 0-3
(A in 8 bit, do any time) 
  A8
  lda #2 ;vram $4000
  jsl oam_tile_addr
  
or...(use the full address)
  SET_OAM_TILE_ADDR  $4000
  
  
oam_spr:
to put 1 sprite on the screen. first set
each of these 5 variables, then call oam_spr
spr_x, spr_y, spr_c (tile #), spr_a (flip, palette, priority),
and spr_h (size, x upper bit)
see examples in defines.asm for attributes, such as
SPR_PAL_2, SPR_PRIOR_0, and SPR_H_FLIP.
  A8
  lda #$10 ;x position of 10
  sta spr_x
  lda #$20 ;y position of 21*
  sta spr_y
  lda #$30 ;tile $30
  sta spr_c
  lda #SPR_PAL_2 ;palette #2
  sta spr_a
  lda #SPR_SIZE_SM ;small
  sta spr_h
  jsl oam_spr
  
*yes, sprites appear 1 pixel low, just like NES
  
(no macro)


oam_meta_spr:
put multiple sprites on screen. first set
each of these 3 variables, then load AX with the
address of the meta sprite data.
spr_x, spr_y, and spr_h (size and upper x bit)
The data is 4 bytes per sprite, ending in 128
relative x, relative y, tile #, attributes
(see examples in defines.asm for attributes)
  AXY16
  lda #.loword(MetaspriteData)
  ldx #^MetaspriteData
  jsl oam_meta_spr
  
(no macro)


pad_poll:
reads both controllers to pad1, pad1_new, pad2, pad2_new
do it at the start of each frame
  jsl pad_poll
  
(no macro)
	
	
rand16:
returns A = 16 bit random #
  A16
  jsl rand16
  
(no macro)
  
  
seed_rand:
pass a 16 bit # to seed the random # generator
probably best to wait till the user presses a button
to seed with an actual random number.
  A16
  lda frame_count
  jsl seed_rand
  
(no macro)

  

-----------------------------------
| vram buffer system for auto-dma |
-----------------------------------

copy_to_vb:
to copy some data to the buffer. This would be step 1.
Internally, it sets some variables...
src_address and num_bytes.
AX = address of the data to be copied.
Y = # of bytes.
  lda #.loword(raw_data)
  ldx #^raw_data
  ldy #100 ;to copy 100 bytes
  jsl copy_to_vb
  
(no macro)
  

vb_buffer_H:
to set a pointer to the data we just copied, and set up
an auto-dma to go left to right. (will occur next nmi).
step 2 would be to calculate a vram address and pass
that # to the variable dst_address, then step 3 is 
to call vb_buffer_H
  A16
  lda #$6123 ;vram address
  sta dst_address
  jsl vb_buffer_H
  
(no macro)
  
  
vb_buffer_V:
same as vb_buffer_H, except the data will go top to bottom
when copied to the vram.
  
(no macro)
  


vram_read:
read some data from the vram to wram.
First set a vram address and increment mode.
;a = destination address
;x = destination bank
;y = length in bytes (should be even)
(AXY in 16 bit, forced blank)
  AXY16
  lda #.loword(wram_dst)
  ldx #^wram_dst
  ldy #100 ;to copy 100 bytes
  jsl vram_read
  
or...  
  READ_FROM_VRAM  wram_dst, length
  
  
vram_dma:
to copy data from wram or rom to the vram.
First set a vram address and increment mode.
;a = source address
;x = source bank
;y = length in bytes
(AXY in 16 bit, forced blank)
  A8
  lda #V_INC_1 ;make sure the increment mode is 1
  sta vram_inc
  AXY16
  lda #$1234 ;vram address
  sta vram_addr

  lda #.loword(wram_dst)
  ldx #^wram_dst
  ldy #100 ;to copy 100 bytes
  jsl vram_read
  
or...  
  DMA_TO_VRAM  src_address, length
  
  
??
mem_clear: use wram_fill_7e or wram_fill_7f, fill value 0
  

wram_fill_7e:
a-L = 8 bit fill value (0 to clear)
x16 = start address (in 7e0000 bank)
y16 = size in bytes
WARNING, do not clear the stack or this will never return.
  A8
  XY16
  lda #$00
  ldx #$2000 ;start at 2000
  ldy #$e000 ;clear e000 bytes
  jsl wram_fill_7e
  
or...  
  CLEAR_7E  value, addr, length  
  
  
wram_fill_7f: 
same as wram_fill_7e, except address will be in 7f0000 bank.
  
or...  
  CLEAR_7F  value, addr, length

  
vram_fill:
to fill an area of vram with an 8 bit value.
first set a vram address and increment mode.
;a = fill value -L 8 bit
;y16 = length in bytes
(A in 8 bit, XY in 16 bit, forced blank)
  A8
  lda #V_INC_1 ;make sure the increment mode is 1
  sta vram_inc
  
  XY16
  ldx bg1_map_base ;vram address
  stx vram_addr

  lda #0 ;fill value
  ldx #$1000 ;# of bytes
  jsl vram_fill
  
(no macro)
  
  
vram_fill2:
to fill an area of vram with a 16 bit value. (slower) 
first set a vram address and increment mode.
;a = fill value -L 8 bit
;y16 = length in WORDS
(AXY in 16 bit, forced blank)
  A8
  lda #V_INC_1 ;make sure the increment mode is 1
  sta vram_inc
  
  AXY16
  lda bg1_map_base ;vram address
  sta vram_addr

  lda #$1234 ;fill value
  ldx #$0800 ;# of WORDS (x2 for bytes)
  jsl vram_fill2
  
(no macro)
  
  
  
pal_all:
to copy 512 bytes to a buffer, to set the full palette
;load A HL with pointer to data
;load X -L with bank of data
(AXY in 16 bit, any time)
  AXY16
  lda #.loword(Palette_Data) ;source address
  ldx #^Palette_Data
  jsl pal_all
  
or...
  COPY_PAL_ALL  src_address
  
  
pal_bg:
to copy 256 bytes to a buffer, to set the bg palette
;load A HL with pointer to data
;load X -L with bank of data
(AXY in 16 bit, any time)
  AXY16
  lda #.loword(Palette_BG) ;source address
  ldx #^Palette_BG
  jsl pal_bg  
  
or...  
  COPY_PAL_BG  src_address
  
  
  
pal_spr:
to copy 256 bytes to a buffer, to set the spr palette
;load A HL with pointer to data
;load X -L with bank of data
(AXY in 16 bit, any time)
  AXY16
  lda #.loword(Palette_SPR) ;source address
  ldx #^Palette_SPR
  jsl pal_spr   
  
or...  
  COPY_PAL_SP  src_address
  
  
pal_row:
to copy 32 bytes to a buffer, to set 1 row of the
palette (16 colors).
;load A HL with pointer to data
;load X -L with bank of data
;load Y -L with color row, 0-15	
(AXY in 16 bit, any time)
  AXY16
  lda #.loword(Palette16) ;source address
  ldx #^Palette16
  ldy #2 ;3rd row
  jsl pal_row
  
or...  
  COPY_PAL_ROW  src_address, row
  
  
  
pal_col:
to set 1 color (2 bytes) anywhere in the palette,
copies to a buffer, which is copied at nmi.
;load A HL with color 0-$7fff
;load X -L with index or the color 0-255
(AXY in 16 bit, any time)
(XY could be 8 bit, it doesn't matter.)
  AXY16
  lda #$7fff ;color (white)
  ldx #$0011 ;0-255
  jsl pal_col
  
or...  
  SET_ONE_COLOR  value, index
  
  
pal_bright:
set the screen brightness. 0 dark to 15 full bright
(A in 8 bit, any time)
  A8
  lda #15
  jsl pal_bright
  
or...  
  SET_BRIGHT  value
  
  
set_mosaic:
changes the mosaic settings. A8 = 0-15
0 = 1x1, F = 16x16
(it is set to affect all BG layers)
(mosaic never affects sprites)
(any time)
  A8
  lda #0 ;off
  jsl set_mosaic
   
or...  
  SET_MOSAIC  value
  
  
pal_fade:
to fade the brightness to a certain value, 0-15.
;a8 = fade to value 0-15  
  A8
  lda #0 ;fade to black
  jsl pal_fade
  
or...  
  BRIGHT_FADE_TO  final 
  
  
mosaic_fade:
to fade the mosaic to a certain value, 0-15.
0 = 1x1, F = 16x16
;a8 = fade to value 0-15  
  A8
  lda #15 ;fade to big blocks
  jsl mosaic_fade
  
or...  
  MOSAIC_FADE_TO  final
  
  
ppu_wait_nmi:
only works if NMI interrupts are ON.
this will wait 1 frame. It waits till an nmi
is triggered and completed.
  jsl ppu_wait_nmi
  
(no macro)

  
delay:
a8 is the # of frames to wait. 0 is 256 frames.
Max is about 4 seconds. If you need more, call
this multiple times.
It consumes 100% of the CPU time.
only works if NMI interrupts are ON.
  A8
  lda #10 ;10 frames
  jsl delay
  
or...  
  DELAY_FOR  frames
  

ppu_off:
turns off the screen.
only works if NMI interrupts are ON.
  jsl ppu_off
  
(no macro)
  

ppu_on:
only works if NMI interrupts are ON.
turns on the screen, assuming you put SOMETHING
on the main screen, and brightness isn't zero.
vram reads/writes won't work while the screen on.
  jsl ppu_on
  
(no macro)
  

 
  
  
multiply:
to multiply 2 8 bit numbers and get a 16 bit result.
(a16, xy8, any time)
;in x and y have 8 bit multipliers
;out a16 = result
  A16
  XY8
  ldx #2
  ldy #3
  jsl multiply
  ;returns A = 6
  
(no macro)
  
  
multiply_fast:
to multiply an 8 bit number by a 16 bit number
and get a 24 bit result. This is much faster than
the other multiply, but only works in BG mode 0-6.
The numbers get weird if either of the negative
bits are set for the multipliers. It is a
"2s compliment multiplication", so FF = -1, FE = -2
;in A = 16 bit multiplier
;in X = 8 bit multiplier
;out A = 16 bit result
;out X = 8 upper most bits if result is > FFFF
  A16
  XY8
  lda #$100
  ldx #$10
  jsl multiply_fast
;result A = $1000 (X = 0)
  
(no macro)
  

divide:
to divide a 16 bit number by an 8 bit number and
get a 16 bit result (and 8 bit remainder)
this is very slow. Use sparingly.
;in a16 = dividend
;in x8 = divisor
;out a16 = quotient
;out x8 = remainder
  A16
  XY8
  lda #$1002
  ldx #$10
  jsl divide
;result A = $100 (X = 2, remainder)
  
(no macro)
  

set_main_screen:
to set which layers are active on the main screen.
this is how you make the screen visible.
see examples in defines.asm, such as ALL_ON_SCREEN
(A in 8 bit, any time)
  A8
  lda #(BG1_ON|SPR_ON)
  jsl set_main_screen
  
or...  
  SET_MAIN_SCR  (BG1_ON|SPR_ON)
  
  
set_sub_screen:
to set which layers are active on the sub screen.
this is for color math.
(A in 8 bit, any time)
  A8
  lda #(BG1_ON|SPR_ON)
  jsl set_main_screen  
  
or...  
  SET_SUB_SCR  (BG1_ON|SPR_ON)
  
  

  

  
  
music.asm
---------

Shiru wrote the SNES GSS tracker and SPC driver code.
The asm code has been modified to work with ca65.
Apparently, there is a bug in the original spc code,
which has been patched, in snesgssP.exe, but I
removed the streaming BRR code to put the patch in.
(see spc_patch.txt for technical details.)

Use the tracker, and export the spc700.bin (holds
the spc driver and the brr samples) and each song...
music_1.bin. Include them in the game code with
.incbin "file"


spc_init:
to load the spc driver into the spc. Pass it a
pointer to the spc700.bin file.
  AXY16
  lda #.loword(music_code)
  ldx #^music_code
  jsl spc_init
;note, this calls the load_data function
;and also calls the initialize command 
;and it finds the address where the song should load.


spc_load_data:
to load data to the spc. You shouldn't need to
call this directly. It uses stack relative
addressing, so you would need to push
several values to the stack before hand.


spc_play_song:
to load a song (after spc_init) to the spc,
and start it playing. It first calls the
stop command, so you shouldn't need to do that.
  AXY16
  lda #.loword(song_address)
  ldx #^song_address
  jsl spc_play_song


spc_command_asm:
to send a command to the spc. Don't call this
directly. It uses stack relative to pass values.


spc_stereo:
to set either mono or stereo. A16 = 0 or 1.
the init code sets it to mono by default.
  A16
  lda #0 (mono) or 1 (stereo)
  jsl spc_stereo
  

spc_global_volume:
to set global volume and speed. I'm not entirely
sure if the speed value is different from the
value used by the SNESGSS tracker, which is 0-99
(fast-slow) but volume should be 0-127.
  AXY16
  lda #speed
  ldx #volume
  jsl spc_global_volume
  
 
spc_channel_volume:
to change the max volume for a specific channel 0-7
  AXY16
  lda #channels 0-7
  ldx #volume   0-127
  jsl spc_channel_volume
  
 
music_stop:
to stop the music, but not sound effects.
  jsl music_stop
  

music_pause:
to pause and unpause, a16 is 0 or 1
  A16
  lda #0 (unpause) or 1 (pause)
  jsl music_pause

  
sound_stop_all:
to stop music and sound effects.
  jsl sound_stop_all
  

sfx_play:
you shouldn't have to call this directly.
uses stack relative to push all values.
use the following.


sfx_play_center:
to play a sound effect pan center. AXY is 8 bit.
;in a= sfx #
;	x= volume 0-127
;	y= sfx channel, needs to be > than max song channel
  AXY8
  lda #0 ;the first sfx
  ldx #127 ;volume
  ldy #7 ;the top channel
  jsl sfx_play_center


sfx_play_left:
same, but pan left.


sfx_play_right:
same, but pan right.


spc streaming was removed.



  
  
more macros

WDM_BREAK
for debugging, MESEN-S breaks on WDM commands in
the debugger.


A8, A16, AXY8, AXY16, XY8, XY16
to change the processor status.


BLOCK_MOVE  length, src_addr, dst_addr
to move from WRAM to WRAM (you can't dma this way)
you would use MVN. this macro simplifies it.
Use long addresses or labels.
  BLOCK_MOVE  100, $7e0000, $7f1234


SET_VRAM_INC  value
to set the vram increment mode.
see examples in defines.asm
  SET_VRAM_INC  V_INC_1
  
  
SET_INTERRUPT
to turn on / off hardware interrupts (nmi, irq,
and controllers). Note IRQ also requires a cli command.
see examples in defines.asm
  SET_INTERRUPT  NO_INTERRUPTS
  SET_INTERRUPT (NMI_ON|AUTO_JOY_ON)

  
  
  